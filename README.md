# boolean类型在Jvm中的表示
```text
boolean类型支持true和false俩种值，但是jvm是无法识别这两种值的，因此在 Java 虚拟机规范中，
boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。
这个编码规则约束了 Java 字节码的具体实现。
```
# Java是如何进行算数运算的？
```text
了解到jvm一般是利用栈帧的操作数栈来进行算数运算的，jvm会将堆上的byte、boolean、char、short类型的数
加载到操作数栈中，并且按照int类型来进行运算，因此boolean、char这些类型需要做零扩展，例如，char的大小为两字节。
在加载的时候char的值会被复制到int的低二字节，高二字节则会用0来填充。又比如对于short两字节数来说根据符号为来进行
int扩展，如果为正int高2位补0，否则补1。至于为什么操作数栈要存储int类型的数据，经过资料得到的解释是为：主要是变长数组不好控制，
所以就选择浪费一些空间，以便访问时直接通过下标来计算地址

```
# 类的加载过程
```text
加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。

链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。

初始化，则是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。
```
# Jvm方法表方面
```text
虚方法调用包括 invokevirtual 指令和 invokeinterface 指令。如果这两种指令所声明的目标方法被标记为 final，那么 Java 虚拟机会采用静态绑定。否则，Java 虚拟机将采用动态绑定，在运行过程中根据调用者的动态类型，来决定具体的目标方法。

Java 虚拟机的动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。在解析虚方法调用时，Java 虚拟机会纪录下所声明的目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。

Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。

当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。否则，Java 虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。
```